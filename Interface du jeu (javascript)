// Fonction pour attribuer des coordonnées à chaque sommet
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
//let player = { x: 220, y: 440, size: 8, color: 'black' };
//let playerActivated = false; // Contrôle si le joueur peut bouger
function assignCoordinates() {
    // Centrer les coordonnées dans un canvas de 1000x1000
    let coordinates = {
        A: [300, 500],
        B: [400, 700],
        C: [600, 500],
        D: [800, 300],
        E: [300, 300],
        F: [400, 100],
        G: [600, 100],
        H: [800, 500],
        I: [900, 300],
        J: [900, 100]
    };

    return coordinates;
}

function sommet_acces(chemin, sommet, coord) {
    // Réinitialiser le canvas avant de redessiner
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Redessiner toutes les arêtes
    for (const [key, value] of Object.entries(chemin)) {
        const [xStart, yStart] = coord[key];
        for (const via in value) {
            value[via].forEach(destination => {
                const [xEnd, yEnd] = coord[destination];
                ctx.beginPath();
                ctx.moveTo(xStart, yStart);
                ctx.lineTo(xEnd, yEnd);
                ctx.stroke();
            });
        }
    }

    // Redessiner les sommets et marquer les accessibles
    for (const [key, value] of Object.entries(chemin)) {
        const [x, y] = coord[key];
        if (key === sommet) {
            // Mettre en surbrillance le sommet actuel
            drawVertices(x, y, 20, key, "yellow");
        } else if (Object.keys(chemin[sommet]).some(via => chemin[sommet][via].includes(key))) {
            // Colorer les sommets accessibles en vert
            drawVertices(x, y, 20, key, "green");
        } else {
            // Redessiner les autres sommets normalement
            drawVertices(x, y, 20, key, "white");
        }
    }
}

// Modifie drawVertices pour permettre des couleurs personnalisées
function drawVertices(x, y, radius, label, color = "white") {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.stroke();

    // Dessiner le texte au centre du cercle
    ctx.fillStyle = "black";
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, x, y);
}

// Fonction pour représenter un graphe
function graph_rep(chemin, coord) {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Dessiner les arêtes d'abord
    for (const [key, value] of Object.entries(chemin)) {
        const [xStart, yStart] = coord[key];

        for (const via in value) {
            value[via].forEach(destination => {
                const [xEnd, yEnd] = coord[destination];
                ctx.beginPath();
                ctx.moveTo(xStart, yStart);
                ctx.lineTo(xEnd, yEnd);
                ctx.stroke();
            });
        }
    }

    // Dessiner les sommets par-dessus les arêtes
    for (const [key, value] of Object.entries(chemin)) {
        const [xStart, yStart] = coord[key];
        drawVertices(xStart, yStart, 20, key);
    }
}

// Exemple d'utilisation
let chemin = {
    A: { '': ['B', 'C', 'E'] },
    B: { 'A': ['C', 'D', 'F'], 'C': ['G'] },
    C: { 'A': ['B'], 'B': ['F', 'H'], 'E': ['D'] },
    D: { 'B': ['H'], 'C': ['G'] },
    E: { 'A': ['F'], 'C': ['A', 'G'] },
    F: { 'B': ['D', 'I'], 'E': ['H', 'J'] },
    G: { 'C': ['I'], 'D': ['H'] },
    H: { 'F': ['I', 'J'], 'G': ['B'] },
    I: { 'G': ['J'], 'H': ['E'] },
    J: { 'F': ['I'], 'I': ['G'] }
};

let nodeCoordinates = assignCoordinates();
graph_rep(chemin, nodeCoordinates);
function verif_sommet(table,depart,arrive){
    for (const [key, value] of Object.entries(table[depart])) {
          for(let e of value){
              if(e==arrive){
                  return 0;
              }
          }
    }
    return 1;
}
canvas.addEventListener('click', (e) => {
    // Sommets de départ et d'arrivée
    let s1 = 'A'; // Remplacez par le sommet initial si dynamique
    let s2 = 'B'; // Remplacez par le sommet cible si dynamique

    // Parcourir les sommets et vérifier si on a cliqué dessus
    for (const [key, value] of Object.entries(nodeCoordinates)) {
        const [xStart, yStart] = value;

        // Vérifier si le clic est proche du sommet actuel
        if (
            (e.clientX < xStart + 20) &&
            (e.clientX > xStart - 20) &&
            (e.clientY < yStart + 20) &&
            (e.clientY > yStart - 20)
        ) {
            // Si le sommet est cliqué, vérifier les critères
            if (verif_sommet(chemin, s1, s2)) {
                console.log(`Critères satisfaits pour le sommet ${key}`);
                sommet_acces(chemin, key, nodeCoordinates); // Action si critères remplis
            } else {
                console.log(`Critères non satisfaits pour le sommet ${key}`);
                // Action si critères non remplis (par exemple, changer `s1`)
                s1 = key; // Mise à jour du sommet initial pour une nouvelle vérification
            }
            break; // On sort de la boucle une fois un sommet cliqué
        }
    }
});


